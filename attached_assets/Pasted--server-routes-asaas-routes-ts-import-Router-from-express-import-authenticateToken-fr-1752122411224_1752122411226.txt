// server/routes/asaas-routes.ts
import { Router } from 'express';
import { authenticateToken } from '../middleware/auth';
import { UnifiedAsaasService } from '../services/unified-asaas-service';

const router = Router();

// Middleware de autenticação para todas as rotas
router.use(authenticateToken);

// Teste de conexão
router.get('/connection-test', async (req, res) => {
  try {
    const asaasService = new UnifiedAsaasService();
    const result = await asaasService.testConnection();
    
    res.json({
      connected: result.success,
      environment: process.env.ASAAS_ENVIRONMENT || 'production',
      message: result.message,
      lastTest: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({
      connected: false,
      message: 'Erro ao testar conexão',
      error: error.message
    });
  }
});

router.post('/connection-test', async (req, res) => {
  try {
    const asaasService = new UnifiedAsaasService();
    const result = await asaasService.testConnection();
    
    res.json({
      connected: result.success,
      environment: process.env.ASAAS_ENVIRONMENT || 'production',
      message: result.message,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({
      connected: false,
      message: 'Erro no teste de conexão',
      error: error.message
    });
  }
});

// Listar pagamentos
router.get('/payments', async (req, res) => {
  try {
    const {
      page = '1',
      limit = '20',
      status,
      billingType,
      search,
      startDate,
      endDate
    } = req.query;

    const asaasService = new UnifiedAsaasService();
    
    const filters: any = {};
    if (status && status !== 'all') filters.status = status;
    if (billingType && billingType !== 'all') filters.billingType = billingType;
    if (startDate) filters.dateCreated = { '[gte]': startDate };
    if (endDate) {
      if (filters.dateCreated) {
        filters.dateCreated['[lte]'] = endDate;
      } else {
        filters.dateCreated = { '[lte]': endDate };
      }
    }
    if (search) filters.customer = search;

    const result = await asaasService.getPayments({
      offset: (parseInt(page as string) - 1) * parseInt(limit as string),
      limit: parseInt(limit as string),
      ...filters
    });

    res.json({
      payments: result.data || [],
      pagination: {
        page: parseInt(page as string),
        limit: parseInt(limit as string),
        total: result.totalCount || 0,
        totalPages: Math.ceil((result.totalCount || 0) / parseInt(limit as string)),
        hasNextPage: result.hasMore || false
      }
    });
  } catch (error) {
    console.error('Erro ao listar pagamentos:', error);
    res.status(500).json({
      error: 'Erro ao listar pagamentos',
      message: error.message
    });
  }
});

// Estatísticas de pagamentos
router.get('/payments/stats', async (req, res) => {
  try {
    const asaasService = new UnifiedAsaasService();
    
    // Buscar estatísticas básicas
    const allPayments = await asaasService.getPayments({ limit: 1000 });
    const payments = allPayments.data || [];

    const stats = {
      total: {
        count: payments.length,
        value: payments.reduce((sum, p) => sum + (p.value || 0), 0)
      },
      pending: {
        count: payments.filter(p => p.status === 'PENDING').length,
        value: payments.filter(p => p.status === 'PENDING').reduce((sum, p) => sum + (p.value || 0), 0)
      },
      confirmed: {
        count: payments.filter(p => ['CONFIRMED', 'RECEIVED'].includes(p.status)).length,
        value: payments.filter(p => ['CONFIRMED', 'RECEIVED'].includes(p.status)).reduce((sum, p) => sum + (p.value || 0), 0)
      },
      overdue: {
        count: payments.filter(p => p.status === 'OVERDUE').length,
        value: payments.filter(p => p.status === 'OVERDUE').reduce((sum, p) => sum + (p.value || 0), 0)
      }
    };

    res.json(stats);
  } catch (error) {
    console.error('Erro ao buscar estatísticas:', error);
    res.status(500).json({
      error: 'Erro ao buscar estatísticas',
      message: error.message
    });
  }
});

// Sincronização
router.post('/sync', async (req, res) => {
  try {
    const asaasService = new UnifiedAsaasService();
    
    // Implementar lógica de sincronização
    const result = await asaasService.syncPayments();
    
    res.json({
      success: true,
      message: `Sincronização concluída. ${result.syncedCount} pagamentos sincronizados.`,
      syncedCount: result.syncedCount,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Erro na sincronização:', error);
    res.status(500).json({
      success: false,
      message: 'Erro na sincronização',
      error: error.message
    });
  }
});

// Cancelar pagamento
router.post('/payments/:id/cancel', async (req, res) => {
  try {
    const { id } = req.params;
    const asaasService = new UnifiedAsaasService();
    
    const result = await asaasService.cancelPayment(id);
    
    res.json({
      success: true,
      message: 'Pagamento cancelado com sucesso',
      payment: result
    });
  } catch (error) {
    console.error('Erro ao cancelar pagamento:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao cancelar pagamento',
      error: error.message
    });
  }
});

// Enviar lembrete
router.post('/payments/:id/reminder', async (req, res) => {
  try {
    const { id } = req.params;
    const { type = 'email' } = req.body;
    const asaasService = new UnifiedAsaasService();
    
    const result = await asaasService.sendPaymentReminder(id, type);
    
    res.json({
      success: true,
      message: 'Lembrete enviado com sucesso',
      result
    });
  } catch (error) {
    console.error('Erro ao enviar lembrete:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao enviar lembrete',
      error: error.message
    });
  }
});

export { router as asaasRoutes };